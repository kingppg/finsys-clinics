// Automated appointment reminders for Messenger bookings, dynamic cron per clinic with hot-reload

require('dotenv').config();

const cron = require('node-cron');
const { Pool } = require('pg');
const axios = require('axios');

// Database connection setup
const pool = new Pool({
  host: process.env.PGHOST || 'localhost',
  user: process.env.PGUSER || 'postgres',
  password: process.env.PGPASSWORD || '860261',
  database: process.env.PGDATABASE || 'dental_clinic',
  port: process.env.PGPORT || 5432
});

// --- Clinic-aware functions ---

// Send Messenger message using clinic's page token
async function sendMessengerMessage(messenger_id, text, page_access_token) {
  if (!messenger_id || !page_access_token) return;
  try {
    await axios.post(
      `https://graph.facebook.com/v17.0/me/messages?access_token=${page_access_token}`,
      {
        recipient: { id: messenger_id },
        message: { text },
      }
    );
    console.log(`✅ Sent Messenger reminder to ${messenger_id}: ${text}`);
  } catch (err) {
    console.error("❌ Error sending Messenger reminder:", err.response?.data || err.message);
  }
}

// Get all clinics with Messenger token and reminder time
async function getAllClinics() {
  const { rows } = await pool.query(`
    SELECT id, name, fb_page_access_token, reminder_time
    FROM clinics
    WHERE fb_page_access_token IS NOT NULL AND reminder_time IS NOT NULL
  `);
  return rows;
}

// Get all upcoming appointments with reminders enabled for a specific clinic
async function getAppointmentsWithReminders(clinic_id) {
  const query = `
    SELECT a.*, p.messenger_id, p.name AS patient_name, a.guardian_messenger_id
    FROM appointments a
    JOIN patients p ON a.patient_id = p.id
    WHERE a.status != 'Cancelled'
      AND (
        (p.messenger_id IS NOT NULL AND p.messenger_id <> '')
        OR (a.guardian_messenger_id IS NOT NULL AND a.guardian_messenger_id <> '')
      )
      AND a.reminder_enabled = true
      AND a.appointment_time > NOW()
      AND a.clinic_id = $1
  `;
  const params = [clinic_id];
  const { rows } = await pool.query(query, params);
  return rows;
}

function isDaysBefore(appointment_time, daysAhead) {
  const appointmentDate = new Date(appointment_time);
  appointmentDate.setHours(0, 0, 0, 0);

  const now = new Date();
  const nowPH = new Date(now.toLocaleString("en-US", { timeZone: "Asia/Manila" }));
  nowPH.setHours(0, 0, 0, 0);

  const timeDiff = appointmentDate.getTime() - nowPH.getTime();
  const days = Math.round(timeDiff / (1000 * 60 * 60 * 24));
  return days === daysAhead;
}

function parseReminderDays(reminder_days) {
  if (!reminder_days || (Array.isArray(reminder_days) && reminder_days.length === 0)) return [];
  if (Array.isArray(reminder_days)) {
    const vals = reminder_days.map(d => Number(d)).filter(d => !isNaN(d));
    return vals;
  }
  if (typeof reminder_days === 'string') {
    try {
      const arr = JSON.parse(reminder_days);
      if (Array.isArray(arr)) {
        const vals = arr.map(d => Number(d)).filter(d => !isNaN(d));
        return vals;
      }
    } catch { /* Ignore error */ }
    const vals = reminder_days.split(',').map(d => Number(d.trim())).filter(d => !isNaN(d));
    return vals;
  }
  return [];
}

async function sendRemindersForClinic(clinic) {
  const clinic_id = clinic.id;
  const page_access_token = clinic.fb_page_access_token;
  const clinic_name = clinic.name;

  console.log(`[ReminderScheduler][${clinic_name}] sendRemindersForClinic started`);
  const appointments = await getAppointmentsWithReminders(clinic_id);
  console.log(`[${clinic_name}] Found ${appointments.length} appointments with reminders enabled.`);

  const nowPH = new Date(new Date().toLocaleString("en-US", { timeZone: "Asia/Manila" }));
  const todayPHStr = nowPH.toISOString().slice(0, 10);

  for (const appt of appointments) {
    const reminderDays = parseReminderDays(appt.reminder_days);
    if (!reminderDays || reminderDays.length === 0) continue;
    for (const daysAhead of reminderDays) {
      if (isDaysBefore(appt.appointment_time, daysAhead)) {
        let recipientMessengerId = appt.messenger_id || appt.guardian_messenger_id;
        if (!recipientMessengerId) continue;

        // Prevent duplicate reminders
        const { rows: alreadySent } = await pool.query(`
          SELECT 1 FROM appointment_reminders
          WHERE appointment_id = $1 AND days_ahead = $2 AND messenger_id = $3 AND sent_on_date = $4 AND is_manual = false
        `, [appt.id, daysAhead, recipientMessengerId, todayPHStr]);
        if (alreadySent.length > 0) continue;

        // Format appointment date/time for message (Asia/Manila)
        const apptDate = new Date(appt.appointment_time);
        const dateStr = apptDate.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
        const timeStr = apptDate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true });

        let reminderText = appt.reminder_message && appt.reminder_message.trim().length > 0
          ? appt.reminder_message
          : `Hello ${appt.patient_name}, this is a reminder for your dental clinic appointment on ${dateStr} at ${timeStr}.`;

        reminderText += `\n\nSee you soon!`;

        await sendMessengerMessage(recipientMessengerId, reminderText, page_access_token);

        await pool.query(`
          INSERT INTO appointment_reminders (appointment_id, sent_on, days_ahead, messenger_id, message, sent_on_date, is_manual, clinic_id)
          VALUES ($1, now(), $2, $3, $4, $5, false, $6)
          ON CONFLICT DO NOTHING
        `, [
          appt.id,
          daysAhead,
          recipientMessengerId,
          reminderText,
          todayPHStr,
          clinic_id
        ]);
        console.log(`[${clinic_name}] Logged reminder for appointment ${appt.id}, ${daysAhead} days ahead.`);
      }
    }
  }
}

// Converts 'HH:MM:SS' or 'HH:MM' to cron string ('m H * * *')
function getCronString(reminderTime) {
  const parts = reminderTime.split(':');
  const hour = parts[0];
  const minute = parts[1] || '0';
  return `${minute} ${hour} * * *`;
}

// --- HOT-RELOAD SCHEDULER LOGIC ---
const scheduledJobs = new Map();

async function rescheduleJobs() {
  const clinics = await getAllClinics();

  // Remove jobs for clinics that no longer exist or have changed time/token
  for (const [clinicId, jobMeta] of scheduledJobs) {
    const clinic = clinics.find(c => c.id === clinicId);
    if (!clinic || jobMeta.reminder_time !== clinic.reminder_time || jobMeta.fb_page_access_token !== clinic.fb_page_access_token) {
      // Remove cron job
      jobMeta.job.stop();
      scheduledJobs.delete(clinicId);
      console.log(`[ReminderScheduler] Removed job for clinic "${jobMeta.name}" (ID ${clinicId})`);
    }
  }

  // Add jobs for new clinics or changed schedule
  for (const clinic of clinics) {
    if (!scheduledJobs.has(clinic.id)) {
      const cronStr = getCronString(clinic.reminder_time);
      const job = cron.schedule(cronStr, async () => {
        await sendRemindersForClinic(clinic);
      });
      scheduledJobs.set(clinic.id, {
        job,
        reminder_time: clinic.reminder_time,
        fb_page_access_token: clinic.fb_page_access_token,
        name: clinic.name
      });
      console.log(`[ReminderScheduler] Scheduled reminders for clinic "${clinic.name}" (ID ${clinic.id}) at ${clinic.reminder_time} (${cronStr})`);
    }
  }
}

// Initial scheduling
rescheduleJobs();

// Poll for changes every 1 minute
setInterval(rescheduleJobs, 1 * 60000);

// For manual running/testing (single clinic)
if (require.main === module) {
  (async () => {
    const clinics = await getAllClinics();
    for (const clinic of clinics) {
      await sendRemindersForClinic(clinic);
    }
    process.exit(0);
  })();
}